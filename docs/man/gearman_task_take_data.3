.TH "GEARMAN_TASK_TAKE_DATA" "3" "May 31, 2011" "0.21" "Gearmand"
.SH NAME
gearman_task_take_data \- Gearmand Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructeredText.
.
.SH SYNOPSIS
.sp
#include <libgearman/gearman.h>
.INDENT 0.0
.TP
.B gearman_task_st
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_task_free(gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B const void *gearman_task_context(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_task_set_context(gearman_task_st *task, void *context);
.UNINDENT
.INDENT 0.0
.TP
.B const char *gearman_task_function_name(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B const char *gearman_task_unique(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B const char *gearman_task_job_handle(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B bool gearman_task_is_known(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B bool gearman_task_is_running(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B uint32_t gearman_task_numerator(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B uint32_t gearman_task_denominator(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_task_give_workload(gearman_task_st *task, const void *workload, size_t workload_size);
.UNINDENT
.INDENT 0.0
.TP
.B size_t gearman_task_send_workload(gearman_task_st *task, const void *workload, size_t workload_size, gearman_return_t *ret_ptr);
.UNINDENT
.INDENT 0.0
.TP
.B const void *gearman_task_data(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B size_t gearman_task_data_size(const gearman_task_st *task);
.UNINDENT
.INDENT 0.0
.TP
.B void *gearman_task_take_data(gearman_task_st *task, size_t *data_size);
.UNINDENT
.INDENT 0.0
.TP
.B size_t gearman_task_recv_data(gearman_task_st *task, void *data, size_t data_size, gearman_return_t *ret_ptr);
.UNINDENT
.sp
Link with \-lgearman
.SH DESCRIPTION
.sp
A \fI\%gearman_task_st\fP represents a "task". Each task is a single unit of work that is executed via \fBgearman_client_run_tasks()\fP.
.sp
\fI\%gearman_task_st\fP structures are create via
\fBgearman_execute()\fP, c:func:\fIgearman_client_add_task()\fP, or
\fBgearman_client_add_task_background()\fP.
.sp
\fBgearman_client_add_task_status()\fP can be used to create a \fI\%gearman_task_st\fP to
monitor a previously created \fI\%gearman_task_st\fP.
.sp
\fBgearman_task_free()\fP is used to free a task. This only needs to be
done if a task was created with a preallocated structure.
.sp
\fBgearman_task_set_context()\fP sets the given context of the \fI\%gearman_task_st\fP. The context can be used to pass information to a \fI\%gearman_task_st\fP.
.sp
\fBgearman_task_context()\fP returns the context that was used in the creation of the \fI\%gearman_task_st\fP (or that was set with \fBgearman_task_set_context()\fP.
.sp
\fBgearman_task_data()\fP returns the current data that has been returned to the task. \fBgearman_task_data_size()\fP will give you the size of the value. \fBgearman_task_take_data()\fP is the same as \fBgearman_task_data()\fP but the value that is returned must be freed by the client (\fIfree(3)\fP). \fBgearman_task_recv_data()\fP can be used with pre\-allocated buffers.
.sp
\fBgearman_task_is_known()\fP, \fBgearman_task_is_running()\fP, \fBgearman_task_numerator()\fP, and \fBgearman_task_denominator()\fP, return values related to the last status update that was made to the \fI\%gearman_task_st\fP. They do not cause the \fI\%gearman_task_st\fP to update itself.
.SH RETURN
.sp
Various. Values that are returned by \fBgearman_task_take_data()\fP must have \fIfree(3)\fP called on them.
.SH HOME
.sp
To find out more information please check:
\fI\%https://launchpad.net/gearmand\fP
.SH SEE ALSO
.sp
\fIgearmand(8)\fP \fIlibgearman(3)\fP
.SH AUTHOR
Data Differential http://datadifferential.com/
.SH COPYRIGHT
2011, Data Differential, http://datadifferential.com/
.\" Generated by docutils manpage writer.
.\" 
.
